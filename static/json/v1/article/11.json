{"errcode":0,"msg":"ok","data":{"article":{"id":11,"title":"jQuery简易使用方法","coverImg":"/image/cover/1.jpg","summary":"jQuery的简单使用方法整理","content":"<h1><a href=\"#jquery\" name=\"jquery\"></a>jQuery</h1>\n<hr/>\n<p>[TOC]</p>\n<h2><a href=\"#节点创建\" name=\"节点创建\"></a>节点创建</h2>\n<h3><a href=\"#节点创建\" name=\"节点创建\"></a>节点创建</h3>\n<p>jQuery中，创建节点可以使用$()函数<br/><code>$(&quot;&lt;div&gt;&lt;/div&gt;&quot;)</code></p>\n<p>创建文本节点可以将文本直接添加进描述中<br/><code>$(&quot;&lt;div&gt;文本内容&lt;/div&gt;&quot;)</code></p>\n<p>在创建节点时，可以同时为节点添加相应的属性<br/><code>$(&quot;&lt;div id=&quot;test&quot; class=&quot;class1&quot;&gt;文本节点&lt;/div&gt;&quot;)</code></p>\n<blockquote>\n  <p>动态创建的节点只保存在内存中</p>\n</blockquote>\n<h3><a href=\"#append与appendto\" name=\"append与appendto\"></a>append与appendTo</h3>\n<p>如果需要将节点动态的创建并保存在文档中，可以使用这两个方法，就节点放到某个元素的内部</p>\n<table>\n  <thead>\n    <tr>\n      <th align=\"center\">选择器</th>\n      <th align=\"center\">描述</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td align=\"center\">append(content)</td>\n      <td align=\"center\">向每个匹配的元素内部追加内容</td>\n    </tr>\n    <tr>\n      <td align=\"center\">appendTo(content)</td>\n      <td align=\"center\">把匹配的元素追加到另一个指定的元素当中</td>\n    </tr>\n  </tbody>\n</table>\n<p>append：这个操作与对指定的元素执行原生的appendChild方法，将它们添加到文档中的情况类似。</p>\n<p>appendTo：实际上，使用这个方法是颠倒了常规的$(A).append(B)的操作，即不是把B追加到A中，而是把A追加到B中。</p>\n<h2><a href=\"#节点插入\" name=\"节点插入\"></a>节点插入</h2>\n<h3><a href=\"#外部插入after和before\" name=\"外部插入after和before\"></a>外部插入after和before</h3>\n<table>\n  <thead>\n    <tr>\n      <th align=\"center\">选择器</th>\n      <th align=\"center\">描述</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td align=\"center\">.after(content)</td>\n      <td align=\"center\">向每个匹配的元素后面追加内容，作为其兄弟节点</td>\n    </tr>\n    <tr>\n      <td align=\"center\">.before(content)</td>\n      <td align=\"center\">向每个匹配的元素前面追加内容，作为其兄弟节点</td>\n    </tr>\n  </tbody>\n</table>\n<p>两个方法都是都可以接收HTML字符串，DOM 元素，元素数组，或者jQuery对象，用来插入到集合中每个匹配元素的前面或者后面</p>\n<p>两个方法都支持多个参数传递after(div1,div2,&hellip;.)</p>\n<h3><a href=\"#内部插入prepend和prependto\" name=\"内部插入prepend和prependto\"></a>内部插入prepend和prependTo</h3>\n<table>\n  <thead>\n    <tr>\n      <th align=\"center\">选择器</th>\n      <th align=\"center\">描述</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td align=\"center\">prepend</td>\n      <td align=\"center\">向每个匹配的元素内部前置内容</td>\n    </tr>\n    <tr>\n      <td align=\"center\">prependTo</td>\n      <td align=\"center\">把匹配的元素前置到另一个指定的元素当中</td>\n    </tr>\n  </tbody>\n</table>\n<blockquote>\n  <p>.prepend()方法将指定元素插入到匹配元素里面作为它的第一个子元素 (如果要作为最后一个子元素插入用.append())</p>\n</blockquote>\n<h3><a href=\"#外部插入insertafter和insertbefore\" name=\"外部插入insertafter和insertbefore\"></a>外部插入insertAfter和insertBefore</h3>\n<table>\n  <thead>\n    <tr>\n      <th align=\"center\">选择器</th>\n      <th align=\"center\">描述</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td align=\"center\">insertBefore</td>\n      <td align=\"center\">在目标元素前面插入集合中每个匹配的元素</td>\n    </tr>\n    <tr>\n      <td align=\"center\">insertAfter</td>\n      <td align=\"center\">在目标元素后面插入集合中每个匹配的元素</td>\n    </tr>\n  </tbody>\n</table>\n<p>.before()和.insertBefore()实现同样的功能。主要的区别是语法——内容和目标的位置。</p>\n<p>对于before()选择表达式在函数前面，内容作为参数，而.insertBefore()刚好相反，内容在方法前面，它将被放在参数里元素的前面<br/>.after()和.insertAfter() 实现同样的功能。</p>\n<p>主要的不同是语法——特别是（插入）内容和目标的位置。 对于after()选择表达式在函数的前面，参数是将要插入的内容。对于 .insertAfter(), 刚好相反，内容在方法前面，它将被放在参数里元素的后面</p>\n<blockquote>\n  <p>before、after与insertBefore。insertAfter的除了目标与位置的不同外，后面的不支持多参数处理</p>\n</blockquote>\n<h2><a href=\"#节点删除\" name=\"节点删除\"></a>节点删除</h2>\n<h3><a href=\"#empty\" name=\"empty\"></a>empty</h3>\n<p>移除指定元素中的所有子节点，元素本身不会被清除<br/><code>&lt;div class=&quot;hello&quot;&gt;&lt;p&gt;内容&lt;/p&gt;&lt;/div&gt;</code></p>\n<p><code>$(&quot;.hello&quot;).empty()</code></p>\n<p>结果为<br/><code>&lt;div class=&quot;hello&quot;&gt;&lt;/div&gt;</code></p>\n<h3><a href=\"#remove\" name=\"remove\"></a>remove</h3>\n<p>remove会将元素自身移除，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的jQuery数据<br/>删除节点的同时将绑定的事件也删除，可以防止内存泄漏</p>\n<p>remove比empty好用的地方就是可以传递一个选择器表达式用来过滤将被移除的匹配元素集合，可以选择性的删除指定的节点<br/>我们可以通过$()选择一组相同的元素，然后通过remove（）传递筛选的规则</p>\n<p>过滤器处理<br/><code>$(&quot;p&quot;).filter(&quot;:contains(&#39;3&#39;)&quot;).remove()</code></p>\n<p>删除所有包含了数字3的p元素</p>\n<h3><a href=\"#detach-保留数据删除\" name=\"detach-保留数据删除\"></a>detach 保留数据删除</h3>\n<p>让一个web元素托管。即从当前页面中移除该元素，但保留这个元素的内存模型对象</p>\n<p>$(&ldquo;div&rdquo;).detach()这一句会移除对象，仅仅是显示效果没有了。但是内存中还是存在的。当你append之后，又重新回到了文档流中。就又显示出来了</p>\n<p>detach方法是JQuery特有的，所以它只能处理通过JQuery的方法绑定的事件或者数据</p>\n<h2><a href=\"#节点复制和替换\" name=\"节点复制和替换\"></a>节点复制和替换</h2>\n<h3><a href=\"#clone\" name=\"clone\"></a>clone</h3>\n<p>.clone()方法深度 复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点<br/>clone方法比较简单就是克隆节点，但是需要注意，如果节点有事件或者数据之类的其他处理，我们需要通过clone(ture)传递一个布尔值ture用来指定，这样不仅仅只是克隆单纯的节点结构，还要把附带的事件与数据给一并克隆了</p>\n<ul>\n  <li>clone()方法时，在将它插入到文档之前，我们可以修改克隆后的元素或者元素内容，如右边代码我 $(this).clone().css(&lsquo;color&rsquo;,&lsquo;red&rsquo;) 增加了一个颜色</li>\n  <li>通过传递true，将所有绑定在原始元素上的事件处理函数复制到克隆元素上</li>\n  <li>clone()方法是jQuery扩展的，只能处理通过jQuery绑定的事件与数据<br/>元素数据（data）内对象和数组不会被复制，将继续被克隆元素和原始元素共享。深复制的所有数据，需要手动复制每一个</li>\n</ul>\n<h3><a href=\"#replacewith和replaceall\" name=\"replacewith和replaceall\"></a>replaceWith和replaceAll</h3>\n<p>.replaceWith(newContent)：用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合</p>\n<p>.replaceAll( target ) ：用集合的匹配元素替换每个目标元素</p>\n<p>简单来说：用$()选择节点A，调用replaceWith方法，传入一个新的内容B（HTML字符串，DOM元素，或者jQuery对象）用来替换选中的节点A</p>\n<pre><code>&lt;div&gt;\r\n    &lt;p&gt;第一段&lt;/p&gt;\r\n    &lt;p&gt;第二段&lt;/p&gt;\r\n    &lt;p&gt;第三段&lt;/p&gt;\r\n&lt;/div&gt;\n</code></pre>\n<p>替换第二段</p>\n<pre><code>$(&quot;p:eq(1)&quot;).replaceWith(&#39;&lt;a style=&quot;color:red&quot;&gt;替换第二段的内容&lt;/a&gt;&#39;)\n</code></pre>\n<p>replaceAll</p>\n<pre><code>$(&#39;&lt;a style=&quot;color:red&quot;&gt;替换第二段的内容&lt;/a&gt;&#39;).replaceAll(&#39;p:eq(1)&#39;)\n</code></pre>\n<h3><a href=\"#wrap\" name=\"wrap\"></a>wrap</h3>\n<p>.wrap( wrappingElement )：在集合中匹配的每个元素周围包裹一个HTML结构<br/>也就是在匹配的元素上添加一个父元素</p>\n<p>.wrap( function ) ：一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象<br/>使用后的效果与直接传递参数是一样，只不过可以把代码写带函数体内部，写法不同而已</p>\n<pre><code>$(&#39;p&#39;).wrap(function() {\r\n    return &#39;&lt;div&gt;&lt;div/&gt;&#39;;   //与第一种类似，只是写法不一样\r\n})\n</code></pre>\n<h3><a href=\"#unwrap\" name=\"unwrap\"></a>unwrap</h3>\n<p>作用与wrap方法是相反的。将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置</p>\n<h3><a href=\"#warpall\" name=\"warpall\"></a>warpAll</h3>\n<p>将集合中的元素用其他元素包裹起来<br/>.wrapAll( wrappingElement)：给集合中匹配的元素增加一个外面包裹HTML结构</p>\n<pre><code>&lt;p&gt;p元素&lt;/p&gt;\r\n&lt;p&gt;p元素&lt;/p&gt;\n</code></pre>\n<p><code>$(&#39;p&#39;).wrapAll(&#39;&lt;div&gt;&lt;/div&gt;&#39;)</code></p>\n<pre><code>&lt;div&gt;\r\n    &lt;p&gt;p元素&lt;/p&gt;\r\n    &lt;p&gt;p元素&lt;/p&gt;\r\n&lt;/div&gt;\n</code></pre>\n<p>.wrapAll( function ) ：一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象<br/>通过回调的方式可以单独处理每一个元素</p>\n<pre><code>$(&#39;p&#39;).wrapAll(function() {\r\n    return &#39;&lt;div&gt;&lt;div/&gt;&#39;;\r\n})\n</code></pre>\n<p>等同于对每个元素进行wrap操作</p>\n<pre><code>&lt;div&gt;\r\n    &lt;p&gt;p元素&lt;/p&gt;\r\n&lt;/div&gt;\r\n&lt;div&gt;\r\n    &lt;p&gt;p元素&lt;/p&gt;\r\n&lt;/div&gt;\n</code></pre>\n<h3><a href=\"#wrapinner\" name=\"wrapinner\"></a>wrapinner</h3>\n<p>将合集中的元素内部所有的子元素用其他元素包裹起来，并当作指定元素的子元素<br/>.wrapInner( wrappingElement)：给集合中匹配的元素的内部，增加包裹的HTML结构</p>\n<pre><code>&lt;p&gt;p元素&lt;/p&gt;\r\n&lt;p&gt;p元素&lt;/p&gt;\n</code></pre>\n<p><code>$(&#39;p&#39;).wrapInner(&#39;&lt;div&gt;&lt;/div&gt;&#39;)</code></p>\n<pre><code>&lt;p&gt;\r\n    &lt;div&gt;p元素&lt;/div&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;\r\n    &lt;div&gt;p元素&lt;/div&gt;\r\n&lt;/p&gt;\n</code></pre>\n<p>.wrapInner( function)：允许我们用一个callback函数做参数，每次遇到匹配元素时，该函数被执行，返回一个DOM元素，jQuery对象，或者HTML片段，用来包住匹配元素的内容</p>\n<pre><code>$(&#39;p&#39;).wrapInner(function() {\r\n    return &#39;&lt;div&gt;&lt;div/&gt;&#39;;\r\n})\n</code></pre>\n<p>等同于第一种写法</p>\n<h2><a href=\"#节点遍历\" name=\"节点遍历\"></a>节点遍历</h2>\n<h3><a href=\"#children\" name=\"children\"></a>children</h3>\n<p>jQuery是一个合集对象，如果想快速查找合集里面的第一级子元素，此时可以用children()方法。这里需要注意：.children(selector) 方法是返回匹配元素集合中每个元素的所有子元素（仅儿子辈，这里可以理解为就是父亲-儿子的关系）</p>\n<pre><code>&lt;div class=&quot;div&quot;&gt;\r\n    &lt;ul class=&quot;son&quot;&gt;\r\n        &lt;li class=&quot;grandson&quot;&gt;1&lt;/li&gt;\r\n    &lt;/ul&gt;\r\n&lt;/div&gt;\n</code></pre>\n<p>代码如果是<code>$(&quot;div&quot;).find()</code>，那么意味着只能找到ul，因为div与ul是父子关系，li与div是祖辈关系，因此无法找到。</p>\n<p>无参数</p>\n<p>允许我们通过在DOM树中对这些元素的直接子元素进行搜索，并且构造一个新的匹配元素的jQuery对象<br/>注意：jQuery是一个合集对象，所以通过children是匹配合集中每一给元素的第一级子元素</p>\n<p>.children()方法选择性地接受同一类型选择器表达式<br/><code>$(&quot;div&quot;).children(&quot;.selected&quot;)</code></p>\n<h3><a href=\"#find\" name=\"find\"></a>find</h3>\n<p>jQuery是一个合集对象，如果想快速查找DOM树中的这些元素的后代元素，此时可以用find()方法，这也是开发使用频率很高的方法。这里要注意 children与find方法的区别，children是父子关系查找，find是后代关系（包含父子关系）</p>\n<p>find是遍历当前元素集合中每个元素的后代。只要符合，不管是儿子辈，孙子辈都可以。<br/>与其他的树遍历方法不同，选择器表达式对于 .find() 是必需的参数。如果我们需要实现对所有后代元素的取回，可以传递通配选择器 &lsquo;*&rsquo;.</p>\n<p>find只在后代中遍历，不包括自己。</p>\n<p>选择器 context 是由.find()方法实现的；因此，<code>$(&#39;li.item-ii&#39;).find(&#39;li&#39;)</code> 等价于 <code>$(&#39;li&#39;, &#39;li.item-ii&#39;)</code>。</p>\n<h3><a href=\"#parent\" name=\"parent\"></a>parent</h3>\n<p>jQuery是一个合集对象，如果想快速查找合集里面的每一个元素的父元素（这里可以理解为就是父亲-儿子的关系），此时可以用parent()方法<br/>此方法只能向上查找一级</p>\n<p>parent()无参数</p>\n<p>parent()方法选择性地接受同一型选择器表达式<br/>同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式</p>\n<h3><a href=\"#parents\" name=\"parents\"></a>parents</h3>\n<p>jQuery是一个合集对象，如果想快速查找合集里面的每一个元素的所有祖辈元素，此时可以用parents()方法</p>\n<p>其实也类似find与children的区别，parent只会查找一级，parents则会往上一直查到查找到祖先节点</p>\n<p>无参数</p>\n<p>parents()方法允许我们能够在DOM树中搜索到这些元素的祖先元素，从有序的向上匹配元素，并根据匹配的元素创建一个新的 jQuery 对象</p>\n<p>返回的元素秩序是从离他们最近的父级元素开始的</p>\n<p>parents()方法选择性地接受同一型选择器表达式</p>\n<blockquote>\n  <p>1 .parents()和.parent()方法是相似的，但后者只是进行了一个单级的DOM树查找<br/>2 <code>$( &quot;html&quot; ).parent()</code>方法返回一个包含document的集合，而<code>$( &quot;html&quot; ).parents()</code>返回一个空集合。</p>\n</blockquote>\n<h3><a href=\"#closest\" name=\"closest\"></a>closest</h3>\n<p>以选定的元素为中心，往内查找可以通过find、children方法。如果往上查找，也就是查找当前元素的父辈祖辈元素，jQuery提供了closest()方法，这个方法类似parents但是又有一些细微的区别，属于使用频率很高的方法</p>\n<p>closest()方法接受一个匹配元素的选择器字符串</p>\n<p>从元素本身开始，在DOM 树上逐级向上级元素匹配，并返回最先匹配的祖先元素<br/><code>$(&quot;div&quot;).closet(&quot;li&#39;)</code><br/>closest()方法给定的jQuery集合或元素来过滤元素<br/>与parents的不同：</p>\n<ul>\n  <li>起始位置不同：.closest开始于当前元素 .parents开始于父元素</li>\n  <li>遍历的目标不同：.closest要找到指定的目标，.parents遍历到文档根元素，closest向上查找，知道找到一个匹配就停止查找，parents一直查找到根元素，并将匹配的元素加入集合</li>\n  <li>结果不同：.closest返回的是包含零个或一个元素的jquery对象，parents返回的是包含零个或一个或多个元素的jquery对象</li>\n</ul>\n<h3><a href=\"#next\" name=\"next\"></a>next</h3>\n<p>next()无参数</p>\n<p>允许我们找遍元素集合中紧跟着这些元素的直接兄弟元素，并根据匹配的元素创建一个新的 jQuery 对象</p>\n<p>next()方法选择性地接受同一类型选择器表达式</p>\n<h3><a href=\"#prev\" name=\"prev\"></a>prev</h3>\n<p>快速查找指定元素集合中每一个元素紧邻的前面同辈元素的元素集合</p>\n<h3><a href=\"#siblings\" name=\"siblings\"></a>siblings</h3>\n<p>快速查找指定元集合中每一个元素紧邻的前面后面同辈元素<br/>如下class=&ldquo;item-2&rdquo;的li元素，class=&ldquo;item-1&rdquo;和class=&ldquo;item-3&rdquo;的节点就是它的siblings兄弟节点</p>\n<pre><code>&lt;ul class=&quot;level-3&quot;&gt;\r\n    &lt;li class=&quot;item-1&quot;&gt;1&lt;/li&gt;\r\n    &lt;li class=&quot;item-2&quot;&gt;2&lt;/li&gt;\r\n    &lt;li class=&quot;item-3&quot;&gt;3&lt;/li&gt;\r\n&lt;/ul&gt;\n</code></pre>\n<h3><a href=\"#add\" name=\"add\"></a>add</h3>\n<p>jQuery是一个合集对象，通过$()方法找到指定的元素合集后可以进行一系列的操作。$()之后就意味着这个合集对象已经是确定的，如果后期需要再往这个合集中添加一新的元素要如何处理？jQuery为此提供add方法，用来创建一个新的jQuery对象 ，元素添加到匹配的元素集合中</p>\n<p>例</p>\n<p>选择所有的li元素，之后需要把p元素也加入到li的合集中</p>\n<pre><code>&lt;ul&gt;\r\n    &lt;li&gt;list item 1&lt;/li&gt;\r\n    &lt;li&gt;list item 3&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;新的p元素&lt;/p&gt;\n</code></pre>\n<ol>\n  <li><code>$(&#39;li&#39;).add(&#39;p&#39;)</code></li>\n  <li><code>$(&#39;li&#39;).add(document.getElementsByTagName(&#39;p&#39;)[0])</code></li>\n  <li><code>$(&#39;li&#39;).add(&#39;&lt;p&gt;新的p元素&lt;/p&gt;&#39;).appendTo(目标位置)</code></li>\n</ol>\n<h3><a href=\"#each\" name=\"each\"></a>each</h3>\n<p>.each() 方法就是一个for循环的迭代器，它会迭代jQuery对象合集中的每一个DOM元素。每次回调函数执行时，会传递当前循环次数作为参数(从0开始计数</p>\n<blockquote>\n  <p>each是一个for循环的包装迭代器</p>\n</blockquote>\n<p>each通过回调的方式处理，并且会有2个固定的实参，索引与元素</p>\n<p>each回调方法中的this指向当前迭代的dom元素</p>\n<p>例</p>\n<pre><code>&lt;ul&gt;\r\n    &lt;li&gt;慕课网&lt;/li&gt;\r\n    &lt;li&gt;Aaron&lt;/li&gt;\r\n&lt;/ul&gt;\n</code></pre>\n<p>开始迭代li，循环2次</p>\n<pre><code>$(&quot;li&quot;).each(function(index, element) {\r\n     index 索引 0,1\r\n     element是对应的li节点 li,li\r\n     this 指向的是li\r\n})\n</code></pre>\n<p>这样可以在循环体会做一些逻辑操作了，如果需要提前退出，可以以通过返回 false以便在回调函数内中止循环</p>","author":"李狗蛋","userId":1,"categoryId":5,"categoryName":"JavaScript","total":null,"tags":[{"id":9,"name":"JQuery","articleNum":null},{"id":4,"name":"JavaScript","articleNum":null},{"id":6,"name":"Web","articleNum":null}],"statistics":{"id":11,"articleId":11,"viewNum":29,"commentNum":0,"createTime":1483096166000},"comments":[]}}}

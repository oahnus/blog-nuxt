{"errcode":0,"msg":"ok","data":{"article":{"id":9,"title":"java中的super关键字","coverImg":"/image/cover/4.jpg","summary":"super关键字有哪些作用","content":"<h2><a href=\"#super关键字\" name=\"super关键字\"></a>super关键字</h2>\n<p>super关键字具有以下作用：</p>\n<ol>\n  <li>调用父类的成员或方法</li>\n  <li>调用父类的构造函数</li>\n</ol>\n<h3><a href=\"#调用父类的构造函数\" name=\"调用父类的构造函数\"></a>调用父类的构造函数</h3>\n<p>使用super关键字可以调用父类的构造函数</p>\n<pre><code>public class Parent{\r\n    public String name;\r\n\r\n    public Parent(){\r\n        // 父类的无参构造函数\r\n    }\r\n\r\n    public Parent(String name){\r\n        this.name = name;\r\n    }\r\n}\n</code></pre>\n<pre><code>public class Son extends Parent{\r\n    public Son(){\r\n\r\n    }\r\n\r\n    public Son(String name){\r\n        super(name);\r\n    }\r\n\r\n    public static void main(String[] args){\r\n        Son son = new Son(&quot;jack&quot;);\r\n        System.out.println(son.name); // 打印jack\r\n    }\r\n}\n</code></pre>\n<p>通过super()调用父类构造器必须放在构造函数第一行。<br/>通过super(),父类的无参构造函数会被执行，通过super(parameter list),父类中的带参数构造函数会被执行。</p>\n<blockquote>\n  <p>如果子类构造函数中没有显式调用父类构造器，则jvm默认调用父类的无参构造函数，如果父类中没有无参构造函数，则报错。</p>\n</blockquote>\n<h3><a href=\"#调用父类中的方法\" name=\"调用父类中的方法\"></a>调用父类中的方法</h3>\n<p>现在在Parent类中添加一个方法</p>\n<pre><code>public void parentMethod(){\r\n    System.out.println(&quot;父类中的方法&quot;);\r\n}\n</code></pre>\n<p>子类中</p>\n<pre><code>public class Son extends Parent {\r\n    public Son(){}\r\n\r\n    public Son(String name) {\r\n        super(name);\r\n    }\r\n\r\n    public void showParentMethod(){\r\n        super.parentMethod();\r\n        this.parentMethod();\r\n    }\r\n    // 为了显示super调用父类的方法，这里重写了父类的方法\r\n    public void parentMethod(){\r\n        System.out.println(&quot;子类中的方法&quot;);\r\n    }\r\n\r\n    public static void main(String[] args){\r\n        Son son = new Son();\r\n        son.showParentMethod();\r\n    }\r\n}\n</code></pre>\n<p>调用Son类中的main方法后，就会在控制台打印出</p>\n<pre><code>父类中的方法\r\n子类中的方法\n</code></pre>\n<p>那么问题来了，super关键字是不是就可以认为是Parent对象的一个引用了?</p>\n<h3><a href=\"#super是指向父类对象的引用-\" name=\"super是指向父类对象的引用-\"></a>super是指向父类对象的引用？</h3>\n<p>回答问题前先来看一下下面的代码</p>\n<pre><code>public class Son extends Parent {\r\n    public Son(String name) {\r\n        super(name);\r\n    }\r\n\r\n    private int age;\r\n\r\n    public Son(){}\r\n\r\n    public void show(){\r\n        System.out.println(super.getClass().getName());\r\n        System.out.println(this.getClass().getName());\r\n    }\r\n\r\n    public static void main(String[] args){\r\n        Son son = new Son();\r\n        son.show();\r\n    }\r\n}\n</code></pre>\n<p>最后打印的是什么？</p>\n<pre><code>Son\r\nSon\n</code></pre>\n<p>也许你会觉得<code>super.getClass().getName()</code>会返回Parent类的名字，可惜不凑巧，你想错了。<br/>为什么super.getClass().getName()会返回子类的名字，super.parentMathod()却可以调用父类的方法?</p>\n<p>其实super在类中并不是父类对象的引用，程序中是不能使用<code>System.out.println(super)</code>打印出super，只是具有调用父类方法的功能。而getClass()方法是Object类的方法，并且是final的，在调用时返回对象在运行时的类的类型。super.getClass()和this.getClass()都是在Son类中调用Object类的getClass()方法，这也就解释了为什么super.getClass().getName()返回的是Son类名了。</p>","author":"李狗蛋","userId":1,"categoryId":1,"categoryName":"Java","total":null,"tags":[{"id":1,"name":"Java","articleNum":null}],"statistics":{"id":9,"articleId":9,"viewNum":7,"commentNum":0,"createTime":1481022385000},"comments":[]}}}

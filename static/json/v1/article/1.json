{"errcode":0,"msg":"ok","data":{"article":{"id":1,"title":"静态代码块与构造函数","coverImg":"/image/cover/1.jpg","summary":"带你搞清静态代码块、代码块与构造函数的执行顺序。","content":"<h2><a href=\"#概念\" name=\"概念\"></a>概念</h2>\n<blockquote>\n  <p>静态代码块：用static{}包围的代码<br/>构造代码块：用{}包围的代码<br/>构造函数：类中与类同名的无返回值函数</p>\n</blockquote>\n<h2><a href=\"#特性\" name=\"特性\"></a>特性</h2>\n<h3><a href=\"#构造函数\" name=\"构造函数\"></a>构造函数</h3>\n<p>构造函数是类中与类同名的无返回值函数</p>\n<pre><code class=\"java\">//A.java\r\npublic class A{\r\n    public A(){\r\n        // 构造函数\r\n    }\r\n}\n</code></pre>\n<ol>\n  <li>在创建类的对象时就会调用其构造函数</li>\n  <li>构造函数的作用就是为对象进行初始化</li>\n  <li>构造函数可以重载，但要保证所有构造函数都有唯一的参数列表</li>\n  <li>当类中没有构造函数，jvm会创建一个无参的默认构造函数</li>\n  <li>当创建子类的对象时，其父类中一定要有无参的构造函数</li>\n</ol>\n<h3><a href=\"#构造代码块\" name=\"构造代码块\"></a>构造代码块</h3>\n<pre><code class=\"java\">public class A{\r\n    {\r\n        //构造代码块\r\n    }\r\n}\n</code></pre>\n<ol>\n  <li>构造代码块也可用于对象的初始化，且先于构造函数执行</li>\n  <li>只用在创建类的对象时才会调用构造代码块</li>\n  <li>一个类中可以有多个构造代码块，且执行顺序按先后位置先后执行</li>\n</ol>\n<h3><a href=\"#静态代码块\" name=\"静态代码块\"></a>静态代码块</h3>\n<pre><code class=\"java\">public class A{\r\n    static{\r\n        // 静态代码块\r\n    }\r\n}\n</code></pre>\n<ol>\n  <li>静态代码块在类被jvm加载时执行，且只执行一次</li>\n  <li>静态代码块中的变量都是局部变量</li>\n  <li>静态代码块中不可使用非static的变量</li>\n  <li>一个类中可以有多个静态代码块</li>\n</ol>\n<h2><a href=\"#三者的执行顺序\" name=\"三者的执行顺序\"></a>三者的执行顺序</h2>\n<p>静态代码块&gt;代码块&gt;构造函数</p>\n<h2><a href=\"#验证\" name=\"验证\"></a>验证</h2>\n<h3><a href=\"#单类\" name=\"单类\"></a>单类</h3>\n<pre><code class=\"java\">public class C {\r\n    static {\r\n        System.out.println(&quot;I am C class static code block&quot;);// 静态代码块\r\n    }\r\n\r\n    public C(){\r\n        System.out.println(&quot;I am C class constructor&quot;);// 构造函数\r\n    }\r\n\r\n    {\r\n        System.out.println(&quot;I am C class code block two&quot;);// 构造代码块\r\n    }\r\n\r\n    {\r\n        System.out.println(&quot;I am C class code block one&quot;);// 构造代码块\r\n    }\r\n\r\n    public static void main(String[] args){\r\n        C c = new C();\r\n    }\r\n}\r\n\n</code></pre>\n<p>执行结果</p>\n<pre><code>I am C class static code block\r\nI am C class code block two\r\nI am C class code block one\r\nI am C class constructor\n</code></pre>\n<p>在main函数中添加C c2 = new C();后再次执行，<br/>执行结果</p>\n<pre><code>I am C class static code block//静态代码块只执行一次\r\nI am C class code block two\r\nI am C class code block one\r\nI am C class constructor\r\nI am C class code block two\r\nI am C class code block one\r\nI am C class constructor\n</code></pre>\n<h3><a href=\"#继承的情况\" name=\"继承的情况\"></a>继承的情况</h3>\n<pre><code class=\"java\">public class A{\r\n    static {\r\n        System.out.println(&quot;I am A class static code block&quot;);\r\n    }\r\n\r\n    public A(){\r\n        System.out.println(&quot;I am A class constructor&quot;);\r\n    }\r\n\r\n    {\r\n        System.out.println(&quot;I am A class code block&quot;);\r\n    }\r\n}\r\npublic class B extends A {\r\n    static {\r\n        System.out.println(&quot;I am B class static code block&quot;);\r\n    }\r\n\r\n    public B(){\r\n        System.out.println(&quot;I am B class constructor&quot;);\r\n    }\r\n\r\n    {\r\n        System.out.println(&quot;I am B class code block&quot;);\r\n    }\r\n\r\n    public static void init(){\r\n        System.out.println(&quot;I am B class static method&quot;);\r\n    }\r\n\r\n    public static void main(String[] args){\r\n        B b = new B();\r\n    }\n</code></pre>\n<p>执行结果</p>\n<pre><code>I am A class static code block\r\nI am B class static code block\r\nI am A class code block\r\nI am A class constructor\r\nI am B class code block\r\nI am B class constructor\n</code></pre>\n<p>由于B类继承A类，由继承特性可以了解到，当调用B类的构造函数时，会隐式的调用A类中的无参构造函数，如果A类仍是某个类的子类，程序会继续向上寻找A类的父类的无参构造函数。<br/>而static代码块的执行方式与之类似，当jvm加载B类时，发现B类继承自A类，因此会优先去执行A类中的静态代码块，然后执行B类的静态代码块，之后依次调用构造代码块和构造函数。</p>\n<p>这里还存在一个问题，那就是main方法的执行时间<br/>如果将main方法中的代码改为</p>\n<pre><code>    System.out.println(&quot;I am B class main method&quot;);\r\n    B b = new B();\r\n    B.init();\n</code></pre>\n<p>执行的结果是:</p>\n<pre><code>I am A class static code block\r\nI am B class static code block\r\nI am B class main method\r\nI am A class code block\r\nI am A class constructor\r\nI am B class code block\r\nI am B class constructor\r\nI am B class static method\r\n\n</code></pre>\n<p>这里可以看到既执行了A类的静态代码块，也执行了B类的静态代码块，之后执行B类中的静态方法。在程序运行时，执行<code>B.main();</code>jvm会去加载B类，当发现B类继承自A类时，会继续加载A类，当所需类都加载完成后，在执行B.init方法。</p>\n<p>因此构造代码块，静态代码块，main方法，构造函数的执行顺序为<br/>静态代码块&gt;main方法&gt;构造代码块&gt;构造函数</p>","author":"李狗蛋","userId":1,"categoryId":1,"categoryName":"Java","total":null,"tags":[{"id":1,"name":"Java","articleNum":null}],"statistics":{"id":5,"articleId":1,"viewNum":0,"commentNum":0,"createTime":1478948398000},"comments":[]}}}


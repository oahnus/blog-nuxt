{"errcode":0,"msg":"ok","data":{"article":{"id":6,"title":"java 多态","coverImg":"/image/cover/2.jpg","summary":"理解java的多态","content":"<h2><a href=\"#多态\" name=\"多态\"></a>多态</h2>\n<p>多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性</p>\n<p>在多态中<br/>指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）</p>\n<h2><a href=\"#分类\" name=\"分类\"></a>分类</h2>\n<p>多态分为编译时多态和运行时多态<br/>编译时多态是静态的，主要指方法的重载<br/>运行时多态是通过动态绑定实现的</p>\n<h2><a href=\"#实现\" name=\"实现\"></a>实现</h2>\n<p>java中实现多态有三个条件：继承，重写，向上转型</p>\n<p>实现多态有两种方式：接口和继承</p>\n<h3><a href=\"#基于继承的多态\" name=\"基于继承的多态\"></a>基于继承的多态</h3>\n<p>基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为</p>\n<p>由于所有的类都是由Object类继承而来，因此假设有类B继承自类A,类B重写了toString方法</p>\n<pre><code>Object o = new B();\r\no.toString();\n</code></pre>\n<p>程序段会执行类B的toString方法，当子类重写父类的方法被调用时，只有对象继承链中的最末端的方法才会被调用，这里Object-&gt;A-&gt;B，B在对象链的末端</p>\n<pre><code>Object o = new A();\r\no.toString();\n</code></pre>\n<p>若A重写了toString方法，执行的是A的toString方法</p>\n<p>对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同<br/>如果父类是抽象类，那么子类必须要实现父类中所有的抽象方法，这样该父类所有的子类一定存在统一的对外接口，但其内部的具体实现可以各异。这样我们就可以使用顶层类提供的统一接口来处理该层次的方法</p>\n<h3><a href=\"#基于接口的多态\" name=\"基于接口的多态\"></a>基于接口的多态</h3>\n<p>继承是通过重写父类的同一方法的几个不同子类来体现的，那么就可就是通过实现接口并覆盖接口中同一方法的几不同的类体现的。<br/>在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法</p>\n<h2><a href=\"#实例\" name=\"实例\"></a>实例</h2>\n<pre><code>public class A {\r\n    public String show(D obj) {\r\n        return (&quot;A and D&quot;);\r\n    }\r\n\r\n    public String show(A obj) {\r\n        return (&quot;A and A&quot;);\r\n    }\r\n\r\n}\r\n\r\npublic class B extends A{\r\n    public String show(B obj){\r\n        return (&quot;B and B&quot;);\r\n    }\r\n\r\n    public String show(A obj){\r\n        return (&quot;B and A&quot;);\r\n    }\r\n}\r\n\r\npublic class C extends B{\r\n\r\n}\r\n\r\npublic class D extends B{\r\n\r\n}\r\n\r\npublic class Test {\r\n    public static void main(String[] args) {\r\n        A a1 = new A();\r\n        A a2 = new B();\r\n        B b = new B();\r\n        C c = new C();\r\n        D d = new D();\r\n\r\n        System.out.println(&quot;1--&quot; + a1.show(b));\r\n        System.out.println(&quot;2--&quot; + a1.show(c));\r\n        System.out.println(&quot;3--&quot; + a1.show(d));\r\n        System.out.println(&quot;4--&quot; + a2.show(b));\r\n        System.out.println(&quot;5--&quot; + a2.show(c));\r\n        System.out.println(&quot;6--&quot; + a2.show(d));\r\n        System.out.println(&quot;7--&quot; + b.show(b));\r\n        System.out.println(&quot;8--&quot; + b.show(c));\r\n        System.out.println(&quot;9--&quot; + b.show(d));      \r\n    }\r\n}\n</code></pre>\n<p>结果</p>\n<pre><code>1--A and A\r\n2--A and A\r\n3--A and D\r\n4--B and A\r\n5--B and A\r\n6--A and D\r\n7--B and B\r\n8--B and B\r\n9--A and D\n</code></pre>\n<p>当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这句话对多态进行了一个概括。其实在继承链中对象方法的调用存在一个优先级：<br/><code>this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)</code></p>\n<p>分析5，a2.show(c)，a2是A类型的引用变量，所以this就代表了A，a2.show(c),它在A类中找发现没有找到，于是到A的超类中找(super)，由于A没有超类（Object除外），所以跳到第三级，也就是this.show((super)O)，C的超类有B、A，所以(super)O为B、A，this同样是A，这里在A中找到了show(A obj)，同时由于a2是B类的一个引用且B类重写了show(A obj)，因此最终会调用子类B类的show(A obj)方法，结果也就是B and A</p>\n<p>方法已经找到了但是我们这里还是存在一点疑问，我们还是来看这句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这我们用一个例子来说明这句话所代表的含义：a2.show(b)</p>\n<p>这里a2是引用变量，为A类型，它引用的是B对象，因此按照上面那句话的意思是说有B来决定调用谁的方法,所以a2.show(b)应该要调用B中的show(B obj)，产生的结果应该是“B and B”，但是为什么会与前面的运行结果产生差异呢？这里我们忽略了后面那句话“但是这儿被调用的方法必须是在超类中定义过的”，那么show(B obj)在A类中存在吗？根本就不存在！所以这句话在这里不适用？那么难道是这句话错误了？非也！其实这句话还隐含这这句话：它仍然要按照继承链中调用方法的优先级来确认。所以它才会在A类中找到show(A obj)，同时由于B重写了该方法所以才会调用B类中的方法，否则就会调用A类中的方法</p>\n<p>所以多态机制遵循的原则概括为：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)</p>","author":"李狗蛋","userId":1,"categoryId":1,"categoryName":"Java","total":null,"tags":[{"id":1,"name":"Java","articleNum":null}],"statistics":{"id":6,"articleId":6,"viewNum":3,"commentNum":0,"createTime":1479726097000},"comments":[]}}}

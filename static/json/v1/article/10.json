{"errcode":0,"msg":"ok","data":{"article":{"id":10,"title":"Python 爬虫入门","coverImg":"/image/cover/1.jpg","summary":"使用Python2.7构建简易爬虫","content":"<h2><a href=\"#爬虫概述\" name=\"爬虫概述\"></a>爬虫概述</h2>\n<p>网络蜘蛛（Web spider）也叫网络爬虫（Web crawler），蚂蚁（ant），自动检索工具（automatic indexer），或者（在FOAF软件概念中）网络疾走（WEB scutter），是一种“自动化浏览网络”的程序，或者说是一种网络机器人。它们被广泛用于互联网搜索引擎或其他类似网站，以获取或更新这些网站的内容和检索方式。它们可以自动采集所有其能够访问到的页面内容，以供搜索引擎做进一步处理（分检整理下载的页面），而使得用户能更快的检索到他们需要的信息。</p>\n<h2><a href=\"#使用爬虫抓取网页\" name=\"使用爬虫抓取网页\"></a>使用爬虫抓取网页</h2>\n<p>想要使用python抓取网页，首先出场的就是urllib2，使用其<code>urlopen</code>方法就可以获取到一个网页信息</p>\n<pre><code class=\"python\">import urllib2\r\nresponse = urllib2.urlopen(&quot;http://baidu.com&quot;)\r\nprint response.read()\n</code></pre>\n<p>对于urllib2库中的urlopen()方法，它可以接受三个参数<br/><code>urlopen(url,data,timeout)</code><br/>url即为URL，data为访问URL时要传送的数据，timeout为超时时间。后两个参数可以不添加，data默认为空None，timeout默认为<code>socket._GLOBAL_DEFAULT_TIMEOUT</code><br/>通过urlopen方法获得的信息保存到response中<br/>通过打印response.read()可以获取网页内容</p>\n<p>第三的参数就是timeout设置</p>\n<p><code>response = urllib2.urlopen(&#39;http://sdfsdf&#39;,timeout=10)</code><br/><code>response = urllib2.urlopen(&#39;http://sdfsdf&#39;,data,10)</code></p>\n<h3><a href=\"#request对象\" name=\"request对象\"></a>Request对象</h3>\n<p>在urlopen的参数中，可以传入一个request请求，我们可以创建一个Request的实例来作为参数传给urlopen</p>\n<pre><code class=\"python\">import urllib2\r\nrequest = urllib2.Request(&quot;http://www.baidu.com&quot;)\r\nresponse = urllib2.urlopen(request)\r\nprint response.read()\n</code></pre>\n<h3><a href=\"#post请求与get请求\" name=\"post请求与get请求\"></a>Post请求与Get请求</h3>\n<h4><a href=\"#post\" name=\"post\"></a>POST</h4>\n<pre><code class=\"python\">import urllib\r\nimport urllib2\r\n\r\nvalues = {&quot;usename&quot;:&quot;12345678@123.com&quot;,&quot;password&quot;:&quot;xxx&quot;}\r\ndata = urllib.urlencode(values)\r\nurl = &quot;http://urlurlurl&quot;\r\nrequest = urllib2.Request(url,data)\r\nresponse = urllib2.urlopen(request)\r\nprint response.read()\n</code></pre>\n<p>还可以使用以下方式定义字典</p>\n<pre><code class=\"python\">values = {}\r\nvalues[&#39;username&#39;] = &quot;123456@123.com&quot;\r\nvalues[&#39;password&#39;] = &quot;123456&quot;\r\ndata = urllib.urlencode(values)\n</code></pre>\n<h4><a href=\"#get\" name=\"get\"></a>GET</h4>\n<pre><code class=\"python\">...\r\ndata = urllib.urlencode(values)\r\nurl = &quot;http://urlurlurl&quot;+&quot;?&quot;+data\r\nrequest = urllib2.Request(url)\n</code></pre>\n<h2><a href=\"#urllib库用法\" name=\"urllib库用法\"></a>Urllib库用法</h2>\n<h3><a href=\"#设置headers\" name=\"设置headers\"></a>设置Headers</h3>\n<p>在Headers里有很多的信息，如文件编码，压缩方式，请求身份等<br/>user_agent就是请求身份<br/><code>&#39;User_Agent&#39;:&#39;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&#39;</code><br/>这样就设置好了一个headers，在构建request时传入，这样在请求页面是，就会与request一起发到服务器上。<br/>另外，有的服务器设置了防盗链，服务器会识别headers中的referer是不是它自己，如果不是，服务器就不会响应请求。<br/><code>&#39;Referer&#39;:&#39;http://urlurlurl&#39;</code><br/>另外，在headers中还有一些其他属性</p>\n<blockquote>\n  <p>User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求<br/>Content-Type : 在使用 REST 接口时，服务器会检查该值，用来确定 HTTP Body 中的内容该怎样解析。<br/>application/xml ： 在 XML RPC，如 RESTful/SOAP 调用时使用<br/>application/json ： 在 JSON RPC 调用时使用<br/>application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使用<br/>在使用服务器提供的 RESTful 或 SOAP 服务时， Content-Type 设置错误会导致服务器拒绝服务</p>\n</blockquote>\n<h3><a href=\"#proxy设置\" name=\"proxy设置\"></a>Proxy设置</h3>\n<p>urllib2默认会使用环境变量http_proxy设置HTTP Proxy.有些网站会检测某一段时间内某个IP的访问次数，如果访问次数过多，会禁止访问。所以可以通过设置一些代理服务器来协助你抓取页面。</p>\n<p>Proxy的用法</p>\n<pre><code class=\"python\">import urllib2\r\nenable_proxy = True\r\nproxy_handler = urllib2.ProxyHandler({&quot;http&quot;:&quot;http://some-proxy.com:8080&quot;})\r\nnull_proxy_handler = urllib2.ProxyHandler({})\r\nif enable_proxy:\r\n    opener = urllib2.build_opener(proxy_handler)\r\nelse:\r\n    opener = urllib2.build_opener(null_proxy_handler)\r\nurllib2.install_opener(opener)\n</code></pre>\n<h3><a href=\"#http的put和delete方法\" name=\"http的put和delete方法\"></a>HTTP的PUT和DELETE方法</h3>\n<blockquote>\n  <p>PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。<br/>DELETE：删除某一个资源。很少用到。</p>\n</blockquote>\n<pre><code class=\"python\">import urllib2\r\nrequest = urllib2.Request(uri, data=data)\r\nrequest.get_method = lambda: &#39;PUT&#39; # or &#39;DELETE&#39;\r\nresponse = urllib2.urlopen(request)\n</code></pre>\n<h2><a href=\"#urlerror异常处理\" name=\"urlerror异常处理\"></a>URLError异常处理</h2>\n<h3><a href=\"#urlerror\" name=\"urlerror\"></a>URLError</h3>\n<p>要想在python中捕获异常，就要用到try-except语句</p>\n<pre><code class=\"python\">import urllib2\r\n\r\nrequset = urllib2.Request(&#39;http://www.xxxxx.com&#39;)\r\ntry:\r\n    urllib2.urlopen(requset)\r\nexcept urllib2.URLError, e:\r\n    print e.reason\n</code></pre>\n<h3><a href=\"#httperror\" name=\"httperror\"></a>HTTPError</h3>\n<p>HTTPError是URLError的子类，HTTPError实例产生后，会有一个code属性。<br/>code属性是服务器返回的状态码<br/>由于HTTPError的父类是URLError，因此父类的异常应该放在子类的后面</p>\n<pre><code class=\"python\">import urllib2\r\n\r\nreq = urllib2.Request(&#39;http://blog.csdn.net/cqcre&#39;)\r\ntry:\r\n    urllib2.urlopen(req)\r\nexcept urllib2.HTTPError, e:\r\n    print e.code\r\nexcept urllib2.URLError, e:\r\n    print e.reason\r\nelse:\r\n    print &quot;OK&quot;\n</code></pre>\n<p>如果捕获到了HTTPError，则输出code，不会再处理URLError异常。如果发生的不是HTTPError，则会去捕获URLError异常，输出错误原因。</p>\n<p>另外还可以加入 hasattr属性提前对属性进行判断</p>\n<pre><code class=\"python\">import urllib2\r\n\r\nreq = urllib2.Request(&#39;http://blog.csdn.net/cqcre&#39;)\r\ntry:\r\n    urllib2.urlopen(req)\r\nexcept urllib2.URLError, e:\r\n    if hasattr(e,&quot;code&quot;):\r\n        print e.code\r\n    if hasattr(e,&quot;reason&quot;):\r\n        print e.reason\r\nelse:\r\n    print &quot;OK&quot;\n</code></pre>\n<h2><a href=\"#cookie的使用\" name=\"cookie的使用\"></a>Cookie的使用</h2>\n<h3><a href=\"#opener\" name=\"opener\"></a>Opener</h3>\n<p>当你获取一个URL你使用一个opener(一个urllib2.OpenerDirector的实例)。在前面，我们都是使用的默认的opener，也就是urlopen。它是一个特殊的opener，可以理解成opener的一个特殊实例，传入的参数仅仅是url，data，timeout。</p>\n<p>如果我们需要用到Cookie，只用这个opener是不能达到目的的，所以我们需要创建更一般的opener来实现对Cookie的设置。</p>\n<h3><a href=\"#cookielib\" name=\"cookielib\"></a>Cookielib</h3>\n<p>cookielib模块的主要作用是提供可存储cookie的对象，以便于与urllib2模块配合使用来访问Internet资源。<br/>可以利用本模块的CookieJar类的对象来捕获cookie并在后续连接请求时重新发送，比如可以实现模拟登录功能。该模块主要的对象有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。</p>\n<blockquote>\n  <p>CookieJar —-派生—-&gt;FileCookieJar —-派生—–&gt;MozillaCookieJar和LWPCookieJar</p>\n</blockquote>\n<h4><a href=\"#获取cookie保存到变量\" name=\"获取cookie保存到变量\"></a>获取Cookie保存到变量</h4>\n<pre><code class=\"python\">import urllib2\r\nimport cookielib\r\n\r\n# 声明CookieJar保存Cookie对象\r\ncookie = cookielib.CookieJar()\r\n\r\n# 创建cookie处理器\r\nhandler = urllib2.HTTPCookieProcessor(cookie)\r\n\r\n# 通过handler构建opener\r\nopener = urllib2.build_opener(handler)\r\n\r\nresponse = opener.open(&#39;http://www.baidu.com&#39;)\r\nfor item in cookie:\r\n    print &#39;Name=&#39;+item.name\r\n    print &#39;Value=&#39;+item.value\n</code></pre>\n<p>打印结果</p>\n<pre><code>Name=BAIDUID\r\nValue=61D539BC6FC3780C74A3F9E76D463B12:FG=1\r\nName=BIDUPSID\r\nValue=61D539BC6FC3780C74A3F9E76D463B12\r\nName=H_PS_PSSID\r\nValue=19684_1433_18240_20076_19860_15268_11463\r\nName=PSTM\r\nValue=1464948230\r\nName=BDSVRTM\r\nValue=0\r\nName=BD_HOME\r\nValue=0\n</code></pre>\n<h4><a href=\"#保存cookie到文件\" name=\"保存cookie到文件\"></a>保存Cookie到文件</h4>\n<pre><code class=\"python\"># -*- coding: utf-8 -*-\r\n\r\nimport urllib2\r\nimport cookielib\r\n\r\n# 设置保存cookie的文件\r\nfilename = &#39;cookie.txt&#39;\r\n# 声明MozillaCookieJar保存cookie，并写入文件\r\ncookie = cookielib.MozillaCookieJar(filename)\r\n\r\n# 创建Cookie管理器\r\nhandler = urllib2.HTTPCookieProcessor(cookie)\r\n\r\n# 构建opener\r\nopener = urllib2.build_opener(handler)\r\n\r\n# 创建请求\r\nresponse = opener.open(&quot;http://www.baidu.com&quot;)\r\n# 保存到文件\r\ncookie.save(ignore_discard=True, ignore_expires=True)\n</code></pre>\n<p>ignore_discard的意思是即使cookies将被丢弃也将它保存下来，ignore_expires的意思是如果在该文件中cookies已经存在，则覆盖原文件写入，在这里，我们将这两个全部设置为True。运行之后，cookies将被保存到cookie.txt文件中</p>\n<h4><a href=\"#从文件中获取cookie并访问\" name=\"从文件中获取cookie并访问\"></a>从文件中获取Cookie并访问</h4>\n<pre><code class=\"python\"># -*- coding: utf-8 -*-\r\nimport urllib2\r\nimport cookielib\r\n\r\n# 创建MozillaCookieJar\r\ncookie = cookielib.MozillaCookieJar()\r\n# 从文件中读取cookie\r\ncookie.load(&#39;cookie.txt&#39;, ignore_expires=True, ignore_discard=True)\r\n# 创建request\r\nrequest = urllib2.Request(&quot;http://www.baidu.com&quot;)\r\n# 创建opener\r\nopener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))\r\nresponse = opener.open(request)\r\nprint response.read()\n</code></pre>\n<h4><a href=\"#利用cookie模拟网站登录\" name=\"利用cookie模拟网站登录\"></a>利用Cookie模拟网站登录</h4>\n<p>利用cookie模拟网站登录学校教务系统，读取课表</p>\n<pre><code class=\"python\"># -*- coding: utf-8 -*-\r\nimport urllib\r\nimport urllib2\r\nimport cookielib\r\n\r\n# 保存cookie的文件\r\nfilename = &#39;cookie.txt&#39;\r\n# 创建cookie\r\ncookie = cookielib.MozillaCookieJar(filename)\r\n# 创建opener\r\nopener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))\r\n# 要提交的登陆账号密码\r\npostdata = urllib.urlencode({&#39;USERNAME&#39;: &#39;1341901120&#39;, &#39;PASSWORD&#39;: &#39;chuxuan123sh&#39;})\r\n# 登陆验证要提交的后台页面地址\r\nloginurl = &#39;http://jwgl.just.edu.cn:8080/jsxsd/xk/LoginToXk&#39;\r\n\r\nresponse = opener.open(loginurl, postdata)\r\n# 保存登陆成功的Cookie\r\ncookie.save(ignore_discard=True, ignore_expires=True)\r\n\r\n# 显示课表的后台页面地址\r\ngradeUrl = &#39;http://jwgl.just.edu.cn:8080/jsxsd/xskb/xskb_list.do&#39;\r\nresponse = opener.open(gradeUrl)\r\n# 显示页面html\r\nprint response.read()\n</code></pre>\n<h2><a href=\"#正则表达式\" name=\"正则表达式\"></a>正则表达式</h2>\n<p><img src=\"../images/python-regex.png\" alt=\"正则表达式\" /></p>\n<h3><a href=\"#正则表达式注解\" name=\"正则表达式注解\"></a>正则表达式注解</h3>\n<h4><a href=\"#贪婪模式与非贪婪模式\" name=\"贪婪模式与非贪婪模式\"></a>贪婪模式与非贪婪模式</h4>\n<p>Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。例如：正则表达式”ab*”如果用于查找”abbbc”，将找到”abbb”。而如果使用非贪婪的数量词”ab*?”，将找到”a”。</p>\n<p>常用非贪婪模式提取</p>\n<h4><a href=\"#反斜杠\" name=\"反斜杠\"></a>反斜杠</h4>\n<p>使用反斜杠作为转义字符<br/>python中可以使用r代替\\<br/>在正则表达式中如果要匹配&ldquo;&quot;,需要写成\\\\,使用r可以写成r&rdquo; \\&ldquo;表示。匹配使用可以写成\\d,r&rdquo; \\d&quot;</p>\n<h4><a href=\"#python-re模块\" name=\"python-re模块\"></a>python Re模块</h4>\n<pre><code class=\"python\">#返回pattern对象\r\nre.compile(string[,flag])  \r\n#以下为匹配所用函数\r\nre.match(pattern, string[, flags])\r\nre.search(pattern, string[, flags])\r\nre.split(pattern, string[, maxsplit])\r\nre.findall(pattern, string[, flags])\r\nre.finditer(pattern, string[, flags])\r\nre.sub(pattern, repl, string[, count])\r\nre.subn(pattern, repl, string[, count])\n</code></pre>\n<p><code>pattern = re.compile(r&#39;hello&#39;)</code></p>\n<p>在参数中我们传入了原生字符串对象，通过compile方法编译生成一个pattern对象，然后我们利用这个对象来进行进一步的匹配<br/>参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如<code>re.I|re.M</code>。</p>\n<pre><code>re.I(全拼：IGNORECASE): 忽略大小写（括号内是完整写法，下同）\r\nre.M(全拼：MULTILINE): 多行模式，改变&#39;^&#39;和&#39;$&#39;的行为（参见上图）\r\nre.S(全拼：DOTALL): 点任意匹配模式，改变&#39;.&#39;的行为\r\nre.L(全拼：LOCALE): 使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定\r\nre.U(全拼：UNICODE): 使预定字符类 \\w \\W \\b \\B \\s \\S \\d \\D 取决于unicode定义的字符属性\r\nre.X(全拼：VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。\n</code></pre>\n<h5><a href=\"#re-match-pattern-string-flags-\" name=\"re-match-pattern-string-flags-\"></a>re.match(pattern, string[, flags])</h5>\n<p>这个方法将会从string（我们要匹配的字符串）的开头开始，尝试匹配pattern，一直向后匹配，如果遇到无法匹配的字符，立即返回None，如果匹配未结束已经到达string的末尾，也会返回None。两个结果均表示匹配失败，否则匹配pattern成功，同时匹配终止，不再对string向后匹配</p>\n<p>match对象的的属性和方法<br/>result.group , result.string</p>\n<ol>\n  <li>string: 匹配时使用的文本。</li>\n  <li>re: 匹配时使用的Pattern对象。</li>\n  <li>pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。</li>\n  <li>endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。</li>\n  <li>lastindex: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。</li>\n  <li>lastgroup: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。</li>\n</ol>\n<p>方法：</p>\n<ol>\n  <li>group([group1, …]):<br/>获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。</li>\n  <li>groups([default]):<br/>以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。</li>\n  <li>groupdict([default]):<br/>返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。</li>\n  <li>start([group]):<br/>返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。</li>\n  <li>end([group]):<br/>返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。</li>\n  <li>span([group]):<br/>返回(start(group), end(group))。</li>\n  <li>expand(template):<br/>将匹配到的分组代入template中然后返回。template中可以使用\\id或\\g、\\g引用分组，但不能使用编号0。\\id与\\g是等价的；但\\10将被认为是第10个分组，如果你想表达\\1之后是字符’0’，只能使用\\g0。</li>\n</ol>\n<h5><a href=\"#re-search-pattern-string-flags-\" name=\"re-search-pattern-string-flags-\"></a>re.search(pattern, string[, flags])</h5>\n<p>search方法与match方法极其类似，区别在于match()函数只检测re是不是在string的开始位置匹配，search()会扫描整个string查找匹配，match（）只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回None。同样，search方法的返回对象同样match()返回对象的方法和属性</p>\n<h5><a href=\"#re-split-pattern-string-maxsplit-\" name=\"re-split-pattern-string-maxsplit-\"></a>re.split(pattern, string[, maxsplit])</h5>\n<p>按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割</p>\n<pre><code>import re\r\n\r\npattern = re.compile(r&#39;\\d+&#39;)\r\nprint re.split(pattern,&#39;one1two2three3four4&#39;)\r\n\r\n### 输出 ###\r\n# [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;, &#39;&#39;]\n</code></pre>\n<h5><a href=\"#re-findall-pattern-string-flags-\" name=\"re-findall-pattern-string-flags-\"></a>re.findall(pattern, string[, flags])</h5>\n<p>搜索string，以列表形式返回全部能匹配的子串</p>\n<pre><code>import re\r\n\r\npattern = re.compile(r&#39;\\d+&#39;)\r\nprint re.findall(pattern,&#39;one1two2three3four4&#39;)\r\n\r\n### 输出 ###\r\n# [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]\n</code></pre>\n<h5><a href=\"#re-finditer-pattern-string-flags-\" name=\"re-finditer-pattern-string-flags-\"></a>re.finditer(pattern, string[, flags])</h5>\n<p>搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器</p>\n<pre><code>import re\r\n\r\npattern = re.compile(r&#39;\\d+&#39;)\r\nfor m in re.finditer(pattern,&#39;one1two2three3four4&#39;):\r\n    print m.group(),\r\n\r\n### 输出 ###\r\n# 1 2 3 4\n</code></pre>\n<h5><a href=\"#re-sub-pattern-repl-string-count-\" name=\"re-sub-pattern-repl-string-count-\"></a>re.sub(pattern, repl, string[, count])</h5>\n<p>使用repl替换string中每一个匹配的子串后返回替换后的字符串。<br/>当repl是一个字符串时，可以使用\\id或\\g、\\g引用分组，但不能使用编号0<br/>当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。<br/>count用于指定最多替换次数，不指定时全部替换</p>\n<pre><code>import re\r\n\r\npattern = re.compile(r&#39;(\\w+) (\\w+)&#39;)\r\ns = &#39;i say, hello world!&#39;\r\n\r\nprint re.sub(pattern,r&#39;\\2 \\1&#39;, s)\r\n\r\ndef func(m):\r\n    return m.group(1).title() + &#39; &#39; + m.group(2).title()\r\n\r\nprint re.sub(pattern,func, s)\r\n\r\n### output ###\r\n# say i, world hello!\r\n# I Say, Hello World!\n</code></pre>\n<h5><a href=\"#re-subn-pattern-repl-string-count-\" name=\"re-subn-pattern-repl-string-count-\"></a>re.subn(pattern, repl, string[, count])</h5>\n<p>返回 (sub(repl, string[, count]), 替换次数)</p>\n<pre><code>import re\r\n\r\npattern = re.compile(r&#39;(\\w+) (\\w+)&#39;)\r\ns = &#39;i say, hello world!&#39;\r\nprint re.subn(pattern,r&#39;\\2 \\1&#39;, s)\r\ndef func(m):\r\n    return m.group(1).title() + &#39; &#39; + m.group(2).title()\r\nprint re.subn(pattern,func, s)\r\n### output ###\r\n# (&#39;say i, world hello!&#39;, 2)\r\n# (&#39;I Say, Hello World!&#39;, 2)\n</code></pre>","author":"李狗蛋","userId":1,"categoryId":2,"categoryName":"Python","total":null,"tags":[{"id":2,"name":"Python","articleNum":null},{"id":6,"name":"Web","articleNum":null},{"id":11,"name":"爬虫","articleNum":null}],"statistics":{"id":10,"articleId":10,"viewNum":1,"commentNum":0,"createTime":1481627268000},"comments":[]}}}

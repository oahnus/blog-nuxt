{"errcode":0,"msg":"ok","data":{"article":{"id":7,"title":"Java中的String类","coverImg":"/image/cover/3.png","summary":"java中的String类","content":"<h2><a href=\"#string\" name=\"string\"></a>String</h2>\n<p>java中的String不是基本类型，是一个不可变对象，String类是final类型的，不可被继承。</p>\n<h3><a href=\"#null-new-string-的区别\" name=\"null-new-string-的区别\"></a>null,&quot;&quot;,new String()的区别</h3>\n<blockquote>\n  <p>null 表示String还没有new，也就是说对象的引用还没有创建，也没有分配内存空间给它；而””、new String()则说明String已经new了，只不过内部为空，但是它创建了对象的引用，是需要分配内存空间的。</p>\n</blockquote>\n<h3><a href=\"#字符串池\" name=\"字符串池\"></a>字符串池</h3>\n<p>每当我们创建一个字符串对象时，首先就会检查字符串池中是否存在字面值相等的字符串。如果有，则不再创建，直接返回字符串池中该对象的引用，若没有则创建新对象然后放入到字符串池中并且返回新建对象的引用。这个机制对提高效率，减少内存空间的占用有很大作用。所以在使用字符串的过程中，推荐使用直接赋值（即<code>String s=&quot;aa&quot;</code>），除非有必要才去新建一个String对象（即<code>String s = new String(&quot;aa&quot;)</code>）<br/>看下面的代码</p>\n<pre><code class=\"java\">public class TestString {\r\n    public static void main(String[] args){\r\n        String str1 = &quot;hello&quot;;\r\n        String str2 = new String(&quot;hello&quot;);\r\n        String str3 = &quot;hel&quot;+&quot;lo&quot;;\r\n        String str4 = new String(&quot;hello&quot;);\r\n        String str5 = &quot;hel&quot;;\r\n        String str6 = str5 + &quot;lo&quot;;\r\n\r\n        System.out.println(str1 == str2);\r\n        System.out.println(str1 == str3);\r\n        System.out.println(str2 == str4);\r\n        System.out.println(str6 == str1);\r\n    }\r\n}\n</code></pre>\n<p>输出结果为：</p>\n<pre><code>false\r\ntrue\r\nfalse\r\nfalse\n</code></pre>\n<p>首先来看，<code>str1 == str2</code>,str1使用字面常量创建字符串hello保存在字符串常量池中，str2使用new关键字创建一个值为hello的字符串对象，保存在堆中。两者的内存地址自然不同。<code>str1 == str3</code>呢？这里要注意的是在使用+拼接字面字符串时，jvm会在编译时执行拼接操作，将结果保存在str3中，由于字符串常量池中已经存在hello字符串了，所以在创建变量str3时，jvm返回了hello的地址，一次打印出true。而<code>str2==str4</code>，str2与str4都使用new关键字创建了值为hello的字符串对象，但两者在堆上的地址并不相同。最后，<code>str6==str1</code>，str6是通过str5和“lo”计算得到的字符串，这种程序中计算得到的字符串是不会放在字符串常量池的，所以其引用地址与str1不同</p>\n<h3><a href=\"#intern方法-\" name=\"intern方法-\"></a>intern方法：</h3>\n<pre><code>String str1 = &quot;hello&quot;;\r\nString str2 = new String(&quot;hello&quot;);\r\nSystem.out.println(str1 == str2);\r\nSystem.out.println(str1 == str2.intern());\n</code></pre>\n<p>结果：</p>\n<pre><code>false\r\ntrue\n</code></pre>\n<p>在使用intern方法后,返回一个字符串常量池中的字符串，此时str与1与str.intern()返回的字符串的地址相同。</p>\n<h2><a href=\"#stringbuffer\" name=\"stringbuffer\"></a>StringBuffer</h2>\n<p>StringBuffer和String一样都是用来存储字符串的，只不过由于他们内部的实现方式不同，导致他们的使用范围不同。对于StringBuffer而言，他在处理字符串时，若是对其进行修改操作，它并不会产生一个新的字符串对象，所以说在内存使用方面它是优于String的</p>\n<h2><a href=\"#stringbuilder\" name=\"stringbuilder\"></a>StringBuilder</h2>\n<p>StringBuilder也是一个可变的字符串对象，他与StringBuffer不同之处就在于它是线程不安全的，基于这点，它的速度一般都比StringBuffer快。与StringBuffer一样，StringBuider的主要操作也是append与insert方法。这两个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符添加或插入到字符串生成器中</p>\n<h2><a href=\"#三者比较\" name=\"三者比较\"></a>三者比较</h2>\n<table>\n  <thead>\n    <tr>\n      <th align=\"center\"> </th>\n      <th align=\"center\">类型</th>\n      <th align=\"center\">可变</th>\n      <th align=\"center\">线程</th>\n      <th align=\"center\">操作</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td align=\"center\">String</td>\n      <td align=\"center\">字符串常量</td>\n      <td align=\"center\">不可变</td>\n      <td align=\"center\">线程安全</td>\n      <td align=\"center\">产生一个新对象</td>\n    </tr>\n    <tr>\n      <td align=\"center\">StringBuffer</td>\n      <td align=\"center\">字符串变量</td>\n      <td align=\"center\">可变</td>\n      <td align=\"center\">线程安全</td>\n      <td align=\"center\">改变自身内容</td>\n    </tr>\n    <tr>\n      <td align=\"center\">StringBuilder</td>\n      <td align=\"center\">字符串变量</td>\n      <td align=\"center\">可变</td>\n      <td align=\"center\">线程安全</td>\n      <td align=\"center\">改变自身内容</td>\n    </tr>\n  </tbody>\n</table>\n<p>并不是所有的String字符串操作都会比StringBuffer慢，在某些特殊的情况下，String字符串的拼接会被JVM解析成StringBuilder对象拼接，在这种情况下String的速度比StringBuffer的速度快。如：</p>\n<pre><code>String name = ”I  ” + ”am ” + ”chenssy ” ;\r\nStringBuffer name = new StringBuffer(”I ”).append(” am ”).append(” chenssy ”);\n</code></pre>\n<p>对于这两种方式，你会发现第一种比第二种快太多了，在这里StringBuffer的优势荡然无存。其真实的原因就在于JVM做了一下优化处理，其实String name = ”I ” + ”am ” + ”chenssy ” ;在JVM眼中就是String name = ”I am chenssy ” ;这样的方式对于JVM而言，真的是不要什么时间。但是如果我们在这个其中增加一个String对象，那么JVM就会按照原来那种规范来构建String对象了</p>\n<h2><a href=\"#字符串拼接方式\" name=\"字符串拼接方式\"></a>字符串拼接方式</h2>\n<p>java中有三种拼装的方法：+、concat()以及append()方法</p>\n<h3><a href=\"#拼接字符串\" name=\"拼接字符串\"></a>+ 拼接字符串</h3>\n<p>我们知道编译器对+进行了优化，它是使用StringBuilder的append()方法来进行处理的，我们知道StringBuilder的速度比StringBuffer的速度更加快，但是为何运行速度还是那样呢？主要是因为编译器使用append()方法追加后要同toString()转换成String字符串，也就说 str +=”b”等同于<code>str = new StringBuilder(str).append(&quot;b&quot;).toString();</code><br/>它变慢的关键原因就在于<code>new StringBuilder()</code>和<code>toString()</code></p>\n<h3><a href=\"#concat-\" name=\"concat-\"></a>concat()</h3>\n<pre><code>public String concat(String str) {\r\n    int otherLen = str.length();\r\n    if (otherLen == 0) {\r\n        return this;\r\n    }\r\n    char buf[] = new char[count + otherLen];\r\n    getChars(0, count, buf, 0);\r\n    str.getChars(0, otherLen, buf, count);\r\n    return new String(0, count + otherLen, buf);\r\n}\n</code></pre>\n<p>这是concat()的源码，它看上去就是一个数字拷贝形式，我们知道数组的处理速度是非常快的，但是由于该方法最后是这样的：return new String(0, count + otherLen, buf);这同样也创建了10W个字符串对象，这是它变慢的根本原因</p>\n<h3><a href=\"#append-\" name=\"append-\"></a>append()</h3>\n<pre><code>public synchronized StringBuffer append(String str) {\r\n    super.append(str);\r\n        return this;\r\n}\n</code></pre>\n<p>StringBuffer的append()方法是直接使用父类AbstractStringBuilder的append()方法，该方法的源码如下</p>\n<pre><code>public AbstractStringBuilder append(String str) {\r\n    if (str == null) str = &quot;null&quot;;\r\n        int len = str.length();\r\n    if (len == 0) return this;\r\n    int newCount = count + len;\r\n    if (newCount &gt; value.length)\r\n        expandCapacity(newCount);\r\n    str.getChars(0, len, value, count);\r\n    count = newCount;\r\n    return this;\r\n}\n</code></pre>\n<p>与concat()方法相似，它也是进行字符数组处理的，加长，然后拷贝，但是请注意它最后是返回并没有返回一个新串，而是返回本身，也就说这这个10W次的循环过程中，它并没有产生新的字符串对象</p>","author":"李狗蛋","userId":1,"categoryId":1,"categoryName":"Java","total":null,"tags":[{"id":1,"name":"Java","articleNum":null}],"statistics":{"id":7,"articleId":7,"viewNum":7,"commentNum":0,"createTime":1479726196000},"comments":[]}}}
